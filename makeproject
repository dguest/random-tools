#!/usr/bin/env bash

set -eu

_usage() {
    echo "${0##*/} [-hrdp] "
}
_help() {
    _usage
    cat <<EOF
Make a project template.
WARNING: use in an empty directory

Options:
 -h: get help
 -r: use ROOT
 -d: use HDF5
 -p <lib name>: make python lib
 -e <exe prefix>: prefix for executables

EOF
}

# __________________________________________________________________
# top level run script

_run() {
    local opt
    local ADD_ROOT=''
    local ADD_HDF=''
    local PYTHON_LIB=''
    local PREFIX=''
    while getopts "hrdp:e:" opt $@; do
	case $opt in
	    h) _help; return 1;;
	    r) ADD_ROOT=1 ;;
	    d) ADD_HDF=1 ;;
	    p) PYTHON_LIB=${OPTARG} ;;
	    e) PREFIX=${OPTARG} ;;
	esac
    done
    if [[ ${VARNAME-} == ? ]] ; then
	echo "error, exiting..." >&2
	return 1
    fi
    shift $(($OPTIND - 1))
    if [[ $@ ]] ; then
	_usage
	echo "error: should get no args, got $@..." >&2
	return 1
    fi
    local MAKEFILE=makefile
    _head_comment >| $MAKEFILE
    _make_base >> $MAKEFILE
    if [ $ADD_HDF ] ; then
	_add_hdf >> $MAKEFILE
    fi
    # _add_ndhist >> $MAKEFILE
    if [ $PYTHON_LIB ] ; then
       _add_python_config >> $MAKEFILE
    fi
    if [ $ADD_ROOT ] ; then
	_add_root >> $MAKEFILE
    fi
    if [ $PYTHON_LIB ] ; then
	_add_python_objects $PYTHON_LIB >> $MAKEFILE
    fi
    if [ $PREFIX ] ; then
	_add_exe_objects $PREFIX >> $MAKEFILE
    fi
    _add_all_call >> $MAKEFILE
    if [ $PYTHON_LIB ] ; then
	_add_python_build $PYTHON_LIB >> $MAKEFILE
    fi
    if [ $PREFIX ] ; then
	_add_exe_build >> $MAKEFILE
    fi
    _add_compile_rule >> $MAKEFILE
    _add_dep_gen >> $MAKEFILE
    _make_obj_dummy testobj
    if [ $PYTHON_LIB ] ; then
	_make_py_dummy $PYTHON_LIB testobj
    fi
    if [ $PREFIX ] ; then
	_make_src_dummy ${PREFIX}main testobj
    fi
}

_head_comment() {
    cat <<EOF
# makefile
# auto generated on $(date)
EOF
}

_make_base() {
    cat <<EOF

# --- set dirs
BUILD        := build
SRC          := src
INC          := include
DICT         := dict
OUTPUT       := bin
LIB          := lib

#  set search path
vpath %.cxx  \$(SRC)
vpath %.hh   \$(INC)
vpath %.h    \$(INC)
vpath %Dict.h \$(DICT)
vpath %Dict.cxx \$(DICT)

# --- set compiler and flags (roll c options and include paths together)
CXX          ?= g++
CXXFLAGS     := -O2 -Wall -fPIC -I\$(INC) -g -std=c++11

# ---- define objects
GEN_OBJ_SRC   := \$(wildcard \$(SRC)/*.cxx)
GEN_OBJ       := \$(notdir \$(GEN_OBJ_SRC:%.cxx=%.o))
GEN_OBJ_PATHS := \$(GEN_OBJ:%=\$(BUILD)/%)

# --- all top level (added further down)
ALL_TOP_LEVEL :=

EOF
}

_add_hdf() {
    cat <<EOF
# --- hdf
HDF_INFO := \$(shell h5c++ -showconfig | grep 'Installation point:')
HDF_PATH := \$(strip \$(shell echo ${HDF_INFO} | cut -d ':' -f 2 ))
ifndef HDF_PATH
\$(error "couldn't find HDF, quitting")
endif

CXXFLAGS     += -I\$(HDF_PATH)/include
LIBS         += -L\$(HDF_PATH)/lib -Wl,-rpath,\$(HDF_PATH)/lib
LIBS         += -lhdf5_cpp -lhdf5

EOF
}

_add_ndhist() {
    cat <<EOF
LIBS         += \$(shell ndhist-config --libs)
CXXFLAGS     += \$(shell ndhist-config --cflags)

EOF
}

_add_python_config() {
    cat <<EOF
# --- python config
PY_CONFIG := python3-config

PY_FLAGS  :=   \$(shell \$(PY_CONFIG) --includes)
PY_LIBS   := -L\$(shell \$(PY_CONFIG) --prefix)/lib
PY_LIBS   +=   \$(shell \$(PY_CONFIG) --libs)

PY_LDFLAGS := \$(LDFLAGS)
PY_LDFLAGS += \$(PY_LIBS)
PY_LDFLAGS += -shared

EOF
}

_add_root() {
    cat <<EOF
# --- load in root config
ROOTCFLAGS    := \$(shell root-config --cflags)
ROOTLIBS      := \$(shell root-config --libs)
# ROOTLIBS      += -lCore -lTree -lRIO
ROOTLDFLAGS   := \$(shell root-config --ldflags)

CXXFLAGS     += \$(ROOTCFLAGS)
LDFLAGS      += \$(ROOTLDFLAGS)
LIBS         += \$(ROOTLIBS)

EOF
}

_add_all_call() {
    cat <<EOF
# --- first call here
all: \$(ALL_TOP_LEVEL)

EOF
}

_add_exe_objects() {
    local PREFIX=$1
    cat <<EOF
# --- stuff used for the c++ executable
EXE_PREFIX   := ${PREFIX}

ALL_EXE_SRC   := \$(wildcard \$(SRC)/\$(EXE_PREFIX)*.cxx)
ALL_EXE       := \$(notdir \$(ALL_EXE_SRC:%.cxx=%))
ALL_EXE_PATHS := \$(ALL_EXE:%=\$(OUTPUT)/%)

# filter out the general objects
GEN_OBJ_PATHS := \$(filter-out \$(BUILD)/\$(EXE_PREFIX)%.o,\$(GEN_OBJ_PATHS))

# add to all top level
ALL_TOP_LEVEL += \$(ALL_EXE_PATHS)

EOF
}
_add_exe_build() {
    cat <<EOF
# build exe
\$(OUTPUT)/\$(EXE_PREFIX)%: \$(GEN_OBJ_PATHS) \$(BUILD)/\$(EXE_PREFIX)%.o
	@mkdir -p \$(OUTPUT)
	@echo "linking $^ --> \$@"
	@\$(CXX) -o \$@ $^ \$(LIBS) \$(LDFLAGS)

EOF
}

_add_python_objects() {
    PYLIB=$1
    cat <<EOF
# --- python top level objects
PY_OBJ       := ${PYLIB}.o
PY_OBJ_PATH  := \$(PY_OBJ:%=\$(BUILD)/%)
PY_SRC_PATH  := \$(PY_OBJ:%.o=\$(SRC)/%.cxx)
PY_SO        := \$(LIB)/${PYLIB}.so

# filter out the general objects
GEN_OBJ_PATHS := \$(filter-out \$(BUILD)/${PYLIB}.o,\$(GEN_OBJ_PATHS))

# add to all top level
ALL_TOP_LEVEL += \$(PY_SO)

EOF
}
_add_python_build(){
    PYLIB=$1
    cat <<EOF
# python object compile
\$(PY_OBJ_PATH): \$(PY_SRC_PATH)
	@echo compiling python object \$@
	@mkdir -p \$(BUILD)
	@\$(CXX) -c \$(CXXFLAGS) \$(PY_FLAGS) $< -o \$@

# python linking
\$(PY_SO): \$(GEN_OBJ_PATHS) \$(PY_OBJ_PATH)
	@mkdir -p \$(LIB)
	@echo "linking $^ --> \$@"
	@\$(CXX) -o \$@ $^ \$(LIBS) \$(PY_LDFLAGS)

EOF
}

_add_compile_rule() {
    cat <<EOF
# compile rule
\$(BUILD)/%.o: %.cxx
	@echo compiling $<
	@mkdir -p \$(BUILD)
	@\$(CXX) -c \$(CXXFLAGS) $< -o \$@

EOF
}

_add_dep_gen() {
    cat <<EOF
# use auto dependency generation
ALLOBJ       := \$(GEN_OBJ)
DEP          := \$(BUILD)

ifneq (\$(MAKECMDGOALS),clean)
ifneq (\$(MAKECMDGOALS),rmdep)
include  \$(ALLOBJ:%.o=\$(DEP)/%.d)
endif
endif

DEPTARGSTR = -MT \$(BUILD)/$*.o -MT \$(DEP)/$*.d
\$(DEP)/%.d: %.cxx
	@echo making dependencies for $<
	@mkdir -p \$(DEP)
	@\$(CXX) -MM -MP \$(DEPTARGSTR) \$(CXXFLAGS) \$(PY_FLAGS) $< -o \$@

# clean
.PHONY : clean rmdep all
CLEANLIST     = *~ *.o *.o~ *.d core
clean:
	rm -fr \$(CLEANLIST) \$(CLEANLIST:%=\$(BUILD)/%) \$(CLEANLIST:%=\$(DEP)/%)
	rm -fr \$(BUILD) \$(DICT)

rmdep:
	rm -f \$(DEP)/*.d
EOF
}

_make_src_dummy() {
    mkdir -p src/
    local EXE_NAME=$1
    local TEST_OBJ=${2-testobj}
    cat <<EOF >| src/${EXE_NAME}.cxx
#include "${TEST_OBJ}.hh"
#include <cstdio>
int main(int argc, char* argv[]) {
  int testint = testfunc();
  printf("bonjour et %i\n", testint);
  return 0;
}
EOF
}

_make_obj_dummy() {
    mkdir -p src/
    mkdir -p include/
    local OBJ_NAME=$1

    cat <<EOF >| src/${OBJ_NAME}.cxx
#include "${OBJ_NAME}.hh"
int testfunc(int in) {
  return in + 1;
}
EOF

    cat <<EOF >| include/${OBJ_NAME}.hh
#ifndef ${OBJ_NAME}
#define ${OBJ_NAME}
int testfunc(int in = 0);
#endif
EOF
}

_make_py_dummy() {
    mkdir -p src/
    local MODNAME=$1
    local TEST_OBJ=${2-testobj}
    cat <<EOF >| src/${MODNAME}.cxx
#include <Python.h>
#include "${TEST_OBJ}.hh"

static PyObject* py_alg(PyObject *self, PyObject *args)
{
  const char* echo_this;
  int some_int = 0;
  bool ok = PyArg_ParseTuple(args,"s|i:alg", &echo_this, &some_int);
  if (!ok) return NULL;
  int newret = testfunc(some_int);
  printf("hi %s %i\n", echo_this, newret);
  return Py_BuildValue("i", newret);
}


static PyMethodDef methods[] = {
  {"test", py_alg, METH_VARARGS,
   "don't ask, read the source"},
  {NULL, NULL, 0, NULL}   /* sentinel */
};

static struct PyModuleDef ${MODNAME} = {
   PyModuleDef_HEAD_INIT,
   "testpy",   /* name of module */
   "this be testpy", /* module documentation, may be NULL */
   -1,       /* size of per-interpreter state of the module,
                or -1 if the module keeps state in global variables. */
   methods
};

extern "C" {
  PyMODINIT_FUNC PyInit_${MODNAME}(void)
  {
    return PyModule_Create(&${MODNAME});
  }
}
EOF
}

_run $@
